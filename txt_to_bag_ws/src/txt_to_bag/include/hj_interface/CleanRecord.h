// Generated by gencpp from file hj_interface/CleanRecord.msg
// DO NOT EDIT!


#ifndef HJ_INTERFACE_MESSAGE_CLEANRECORD_H
#define HJ_INTERFACE_MESSAGE_CLEANRECORD_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace hj_interface
{
template <class ContainerAllocator>
struct CleanRecord_
{
  typedef CleanRecord_<ContainerAllocator> Type;

  CleanRecord_()
    : clean_speed(0.0)
    , surface_clean_area(0.0)
    , bottom_clean_area(0.0)
    , wall_clean_area(0.0)
    , pool_area(0.0)
    , pool_volume(0.0)
    , pool_depth(0.0)
    , pool_shape(0)
    , map_line_file_path()
    , start_turbidity(0)
    , end_turbidity(0)
    , build_map_faile_reson(0)
    , build_map_fail_count(0)
    , basket_block_time(0)
    , phy_area(0.0)
    , charge_position(0)
    , in_water_positon(0)
    , fall_count(0)
    , loop(0)
    , density(0)
    , in_water_signal(0)
    , in_water_level(0)
    , charge_signal(0)
    , charge_level(0)
    , mode(0)
    , clean_area(0.0)
    , trapped_reason()
    , trapped_count(0)
    , task_status(0)
    , mapped_area(0.0)
    , untrapped_status(0)
    , untrapped_count(0)
    , suface_border_max(0.0)
    , suface_border_min(0.0)
    , suface_border_avg(0.0)
    , suface_border_std(0.0)
    , ject_count(0)
    , suface_init_time(0)
    , bottom_avoidance_count(0)
    , miss_area(0.0)
    , relocation_status(0)
    , relocation_fail_reason(0)
    , bottom_border_max(0.0)
    , bottom_border_min(0.0)
    , bottom_border_avg(0.0)
    , bottom_border_std(0.0)
    , bottom_border_start_time(0)
    , bottom_border_end_time(0)
    , bottom_border_fail_time(0)
    , bottom_border_status(0)
    , bottom_init_time(0)
    , pitch()
    , under_view(0)
    , relocation_start_time(0)
    , relocation_end_time(0)
    , wall_avoidance_count(0)
    , wall_move()
    , wall_move_count(0)
    , recall_status(0)
    , compensate_reason(0)
    , compensate_retry(0)
    , compensate_status(0)  {
    }
  CleanRecord_(const ContainerAllocator& _alloc)
    : clean_speed(0.0)
    , surface_clean_area(0.0)
    , bottom_clean_area(0.0)
    , wall_clean_area(0.0)
    , pool_area(0.0)
    , pool_volume(0.0)
    , pool_depth(0.0)
    , pool_shape(0)
    , map_line_file_path(_alloc)
    , start_turbidity(0)
    , end_turbidity(0)
    , build_map_faile_reson(0)
    , build_map_fail_count(0)
    , basket_block_time(0)
    , phy_area(0.0)
    , charge_position(0)
    , in_water_positon(0)
    , fall_count(0)
    , loop(0)
    , density(0)
    , in_water_signal(0)
    , in_water_level(0)
    , charge_signal(0)
    , charge_level(0)
    , mode(0)
    , clean_area(0.0)
    , trapped_reason(_alloc)
    , trapped_count(0)
    , task_status(0)
    , mapped_area(0.0)
    , untrapped_status(0)
    , untrapped_count(0)
    , suface_border_max(0.0)
    , suface_border_min(0.0)
    , suface_border_avg(0.0)
    , suface_border_std(0.0)
    , ject_count(0)
    , suface_init_time(0)
    , bottom_avoidance_count(0)
    , miss_area(0.0)
    , relocation_status(0)
    , relocation_fail_reason(0)
    , bottom_border_max(0.0)
    , bottom_border_min(0.0)
    , bottom_border_avg(0.0)
    , bottom_border_std(0.0)
    , bottom_border_start_time(0)
    , bottom_border_end_time(0)
    , bottom_border_fail_time(0)
    , bottom_border_status(0)
    , bottom_init_time(0)
    , pitch(_alloc)
    , under_view(0)
    , relocation_start_time(0)
    , relocation_end_time(0)
    , wall_avoidance_count(0)
    , wall_move(_alloc)
    , wall_move_count(0)
    , recall_status(0)
    , compensate_reason(0)
    , compensate_retry(0)
    , compensate_status(0)  {
  (void)_alloc;
    }



   typedef float _clean_speed_type;
  _clean_speed_type clean_speed;

   typedef float _surface_clean_area_type;
  _surface_clean_area_type surface_clean_area;

   typedef float _bottom_clean_area_type;
  _bottom_clean_area_type bottom_clean_area;

   typedef float _wall_clean_area_type;
  _wall_clean_area_type wall_clean_area;

   typedef float _pool_area_type;
  _pool_area_type pool_area;

   typedef float _pool_volume_type;
  _pool_volume_type pool_volume;

   typedef float _pool_depth_type;
  _pool_depth_type pool_depth;

   typedef int32_t _pool_shape_type;
  _pool_shape_type pool_shape;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _map_line_file_path_type;
  _map_line_file_path_type map_line_file_path;

   typedef int32_t _start_turbidity_type;
  _start_turbidity_type start_turbidity;

   typedef int32_t _end_turbidity_type;
  _end_turbidity_type end_turbidity;

   typedef int32_t _build_map_faile_reson_type;
  _build_map_faile_reson_type build_map_faile_reson;

   typedef int32_t _build_map_fail_count_type;
  _build_map_fail_count_type build_map_fail_count;

   typedef int32_t _basket_block_time_type;
  _basket_block_time_type basket_block_time;

   typedef float _phy_area_type;
  _phy_area_type phy_area;

   typedef int32_t _charge_position_type;
  _charge_position_type charge_position;

   typedef int32_t _in_water_positon_type;
  _in_water_positon_type in_water_positon;

   typedef int32_t _fall_count_type;
  _fall_count_type fall_count;

   typedef int32_t _loop_type;
  _loop_type loop;

   typedef int32_t _density_type;
  _density_type density;

   typedef int32_t _in_water_signal_type;
  _in_water_signal_type in_water_signal;

   typedef int32_t _in_water_level_type;
  _in_water_level_type in_water_level;

   typedef int32_t _charge_signal_type;
  _charge_signal_type charge_signal;

   typedef int32_t _charge_level_type;
  _charge_level_type charge_level;

   typedef int32_t _mode_type;
  _mode_type mode;

   typedef float _clean_area_type;
  _clean_area_type clean_area;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _trapped_reason_type;
  _trapped_reason_type trapped_reason;

   typedef int32_t _trapped_count_type;
  _trapped_count_type trapped_count;

   typedef int32_t _task_status_type;
  _task_status_type task_status;

   typedef float _mapped_area_type;
  _mapped_area_type mapped_area;

   typedef int32_t _untrapped_status_type;
  _untrapped_status_type untrapped_status;

   typedef int32_t _untrapped_count_type;
  _untrapped_count_type untrapped_count;

   typedef float _suface_border_max_type;
  _suface_border_max_type suface_border_max;

   typedef float _suface_border_min_type;
  _suface_border_min_type suface_border_min;

   typedef float _suface_border_avg_type;
  _suface_border_avg_type suface_border_avg;

   typedef float _suface_border_std_type;
  _suface_border_std_type suface_border_std;

   typedef int32_t _ject_count_type;
  _ject_count_type ject_count;

   typedef int32_t _suface_init_time_type;
  _suface_init_time_type suface_init_time;

   typedef int32_t _bottom_avoidance_count_type;
  _bottom_avoidance_count_type bottom_avoidance_count;

   typedef float _miss_area_type;
  _miss_area_type miss_area;

   typedef int32_t _relocation_status_type;
  _relocation_status_type relocation_status;

   typedef int32_t _relocation_fail_reason_type;
  _relocation_fail_reason_type relocation_fail_reason;

   typedef float _bottom_border_max_type;
  _bottom_border_max_type bottom_border_max;

   typedef float _bottom_border_min_type;
  _bottom_border_min_type bottom_border_min;

   typedef float _bottom_border_avg_type;
  _bottom_border_avg_type bottom_border_avg;

   typedef float _bottom_border_std_type;
  _bottom_border_std_type bottom_border_std;

   typedef int32_t _bottom_border_start_time_type;
  _bottom_border_start_time_type bottom_border_start_time;

   typedef int32_t _bottom_border_end_time_type;
  _bottom_border_end_time_type bottom_border_end_time;

   typedef int32_t _bottom_border_fail_time_type;
  _bottom_border_fail_time_type bottom_border_fail_time;

   typedef int32_t _bottom_border_status_type;
  _bottom_border_status_type bottom_border_status;

   typedef int32_t _bottom_init_time_type;
  _bottom_init_time_type bottom_init_time;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _pitch_type;
  _pitch_type pitch;

   typedef int32_t _under_view_type;
  _under_view_type under_view;

   typedef int32_t _relocation_start_time_type;
  _relocation_start_time_type relocation_start_time;

   typedef int32_t _relocation_end_time_type;
  _relocation_end_time_type relocation_end_time;

   typedef int32_t _wall_avoidance_count_type;
  _wall_avoidance_count_type wall_avoidance_count;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _wall_move_type;
  _wall_move_type wall_move;

   typedef int32_t _wall_move_count_type;
  _wall_move_count_type wall_move_count;

   typedef int32_t _recall_status_type;
  _recall_status_type recall_status;

   typedef int32_t _compensate_reason_type;
  _compensate_reason_type compensate_reason;

   typedef int32_t _compensate_retry_type;
  _compensate_retry_type compensate_retry;

   typedef int32_t _compensate_status_type;
  _compensate_status_type compensate_status;





  typedef boost::shared_ptr< ::hj_interface::CleanRecord_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hj_interface::CleanRecord_<ContainerAllocator> const> ConstPtr;

}; // struct CleanRecord_

typedef ::hj_interface::CleanRecord_<std::allocator<void> > CleanRecord;

typedef boost::shared_ptr< ::hj_interface::CleanRecord > CleanRecordPtr;
typedef boost::shared_ptr< ::hj_interface::CleanRecord const> CleanRecordConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hj_interface::CleanRecord_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hj_interface::CleanRecord_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::hj_interface::CleanRecord_<ContainerAllocator1> & lhs, const ::hj_interface::CleanRecord_<ContainerAllocator2> & rhs)
{
  return lhs.clean_speed == rhs.clean_speed &&
    lhs.surface_clean_area == rhs.surface_clean_area &&
    lhs.bottom_clean_area == rhs.bottom_clean_area &&
    lhs.wall_clean_area == rhs.wall_clean_area &&
    lhs.pool_area == rhs.pool_area &&
    lhs.pool_volume == rhs.pool_volume &&
    lhs.pool_depth == rhs.pool_depth &&
    lhs.pool_shape == rhs.pool_shape &&
    lhs.map_line_file_path == rhs.map_line_file_path &&
    lhs.start_turbidity == rhs.start_turbidity &&
    lhs.end_turbidity == rhs.end_turbidity &&
    lhs.build_map_faile_reson == rhs.build_map_faile_reson &&
    lhs.build_map_fail_count == rhs.build_map_fail_count &&
    lhs.basket_block_time == rhs.basket_block_time &&
    lhs.phy_area == rhs.phy_area &&
    lhs.charge_position == rhs.charge_position &&
    lhs.in_water_positon == rhs.in_water_positon &&
    lhs.fall_count == rhs.fall_count &&
    lhs.loop == rhs.loop &&
    lhs.density == rhs.density &&
    lhs.in_water_signal == rhs.in_water_signal &&
    lhs.in_water_level == rhs.in_water_level &&
    lhs.charge_signal == rhs.charge_signal &&
    lhs.charge_level == rhs.charge_level &&
    lhs.mode == rhs.mode &&
    lhs.clean_area == rhs.clean_area &&
    lhs.trapped_reason == rhs.trapped_reason &&
    lhs.trapped_count == rhs.trapped_count &&
    lhs.task_status == rhs.task_status &&
    lhs.mapped_area == rhs.mapped_area &&
    lhs.untrapped_status == rhs.untrapped_status &&
    lhs.untrapped_count == rhs.untrapped_count &&
    lhs.suface_border_max == rhs.suface_border_max &&
    lhs.suface_border_min == rhs.suface_border_min &&
    lhs.suface_border_avg == rhs.suface_border_avg &&
    lhs.suface_border_std == rhs.suface_border_std &&
    lhs.ject_count == rhs.ject_count &&
    lhs.suface_init_time == rhs.suface_init_time &&
    lhs.bottom_avoidance_count == rhs.bottom_avoidance_count &&
    lhs.miss_area == rhs.miss_area &&
    lhs.relocation_status == rhs.relocation_status &&
    lhs.relocation_fail_reason == rhs.relocation_fail_reason &&
    lhs.bottom_border_max == rhs.bottom_border_max &&
    lhs.bottom_border_min == rhs.bottom_border_min &&
    lhs.bottom_border_avg == rhs.bottom_border_avg &&
    lhs.bottom_border_std == rhs.bottom_border_std &&
    lhs.bottom_border_start_time == rhs.bottom_border_start_time &&
    lhs.bottom_border_end_time == rhs.bottom_border_end_time &&
    lhs.bottom_border_fail_time == rhs.bottom_border_fail_time &&
    lhs.bottom_border_status == rhs.bottom_border_status &&
    lhs.bottom_init_time == rhs.bottom_init_time &&
    lhs.pitch == rhs.pitch &&
    lhs.under_view == rhs.under_view &&
    lhs.relocation_start_time == rhs.relocation_start_time &&
    lhs.relocation_end_time == rhs.relocation_end_time &&
    lhs.wall_avoidance_count == rhs.wall_avoidance_count &&
    lhs.wall_move == rhs.wall_move &&
    lhs.wall_move_count == rhs.wall_move_count &&
    lhs.recall_status == rhs.recall_status &&
    lhs.compensate_reason == rhs.compensate_reason &&
    lhs.compensate_retry == rhs.compensate_retry &&
    lhs.compensate_status == rhs.compensate_status;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::hj_interface::CleanRecord_<ContainerAllocator1> & lhs, const ::hj_interface::CleanRecord_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace hj_interface

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::hj_interface::CleanRecord_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hj_interface::CleanRecord_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hj_interface::CleanRecord_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hj_interface::CleanRecord_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hj_interface::CleanRecord_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hj_interface::CleanRecord_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hj_interface::CleanRecord_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e48d559db4dcd2d3151cd7918a8f7973";
  }

  static const char* value(const ::hj_interface::CleanRecord_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe48d559db4dcd2d3ULL;
  static const uint64_t static_value2 = 0x151cd7918a8f7973ULL;
};

template<class ContainerAllocator>
struct DataType< ::hj_interface::CleanRecord_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hj_interface/CleanRecord";
  }

  static const char* value(const ::hj_interface::CleanRecord_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hj_interface::CleanRecord_<ContainerAllocator> >
{
  static const char* value()
  {
    return "## 清洁日志消息\n"
"float32 clean_speed             # 清洁速度 单位：m/s\n"
"float32 surface_clean_area      # 清洁水面面积 单位：m2\n"
"float32 bottom_clean_area       # 清洁池底面积\n"
"float32 wall_clean_area         # 清洁池壁面积\n"
"float32 pool_area               # 泳池面积\n"
"float32 pool_volume             # 泳池体积\n"
"float32 pool_depth              # 泳池深度\n"
"int32   pool_shape              # 泳池形状\n"
"string map_line_file_path       # 地图轨迹文件路径\n"
"\n"
"## 清洁事件消息- 还有一部分放在清洁日志消息中\n"
"int32 start_turbidity          # 起始浊度\n"
"int32 end_turbidity            # 终止浊度\n"
"int32 build_map_faile_reson    # 地图构建失败原因\n"
"int32 build_map_fail_count     # 地图构建失败次数\n"
"int32 basket_block_time        # 滤篮开始堵塞时间\n"
"float32 phy_area               # 物理面积\n"
"int32 charge_position          # 充电点位次数\n"
"int32 in_water_positon         # 入水点位次数\n"
"int32 fall_count               # 跌落次数\n"
"int32 loop                     # 回环误差值\n"
"int32 density                  # 水密度值\n"
"int32 in_water_signal          # 入水点信号强度\n"
"int32 in_water_level           # 入水点等级\n"
"int32 charge_signal            # 充电信号强度\n"
"int32 charge_level             # 充电点等级\n"
"#磁力计信息-半小时1次，单任务6次\n"
"\n"
"## 清洁不同区域共同信息\n"
"int32 mode                     # 清扫模式   1-水面模式 2-池底 3-池壁\n"
"float32 clean_area             # 清扫面积\n"
"int32[] trapped_reason         # 被困触发条件\n"
"int32 trapped_count            # 被困次数\n"
"int32 task_status              # 任务状态 0-失败 1-成功\n"
"float32 mapped_area            # 建图面积\n"
"int32 untrapped_status         # 脱困状态  0-未脱困 1-脱困\n"
"int32 untrapped_count          # 脱困次数\n"
"\n"
"## 水面清洁信息\n"
"float32 suface_border_max      # 延边最大距离\n"
"float32 suface_border_min      # 延边最小距离\n"
"float32 suface_border_avg      # 延边平均距离\n"
"float32 suface_border_std      # 延边方差\n"
"int32 ject_count               # 水面喷口角度变化的次数（水面）\n"
"int32 suface_init_time         # 定位初始化时长\n"
"\n"
"## 池底清洁信息\n"
"int32 bottom_avoidance_count   # 避障次数\n"
"float32 miss_area              # 单边弓任务漏扫区域面积（池底）\n"
"int32 relocation_status        # 重定位状态 0-失败 1-成功\n"
"int32 relocation_fail_reason   # 重定位失败原因（池底）\n"
"float32 bottom_border_max      # 延边最大距离\n"
"float32 bottom_border_min      # 延边最小距离\n"
"float32 bottom_border_avg      # 延边平均距离\n"
"float32 bottom_border_std      # 延边方差\n"
"int32 bottom_border_start_time   # 延边开始时间\n"
"int32 bottom_border_end_time     # 延边结束时间\n"
"int32 bottom_border_fail_time    # 延边失败时间\n"
"int32 bottom_border_status       # 延边状态 0-失败 1-成功\n"
"int32 bottom_init_time         # 定位初始化时长\n"
"int32[] pitch                  # 俯仰角度数（池底）-单任务5次\n"
"int32 under_view               # 下视触发次数（池底）\n"
"int32 relocation_start_time    # 重定位开始时间\n"
"int32 relocation_end_time      # 重定位结束时间\n"
"\n"
"## 池壁清洁信息\n"
"int32 wall_avoidance_count     # 避障次数\n"
"# yaw角度，yaw角度占比值\n"
"int32[] wall_move              # 池壁侧移触发原因（池壁）\n"
"int32 wall_move_count          # 池壁侧移次数（池壁）\n"
"\n"
"## 召回\n"
"int32 recall_status            # 召回状态 0-失败 1-成功\n"
"\n"
"## 回充\n"
"int32 compensate_reason        # 回充原因 0-低电量 1-任务结束 2-召回\n"
"int32 compensate_retry         # 回充对桩尝试次数\n"
"int32 compensate_status        # 回充上电状态 0-失败 1-成功\n"
;
  }

  static const char* value(const ::hj_interface::CleanRecord_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hj_interface::CleanRecord_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.clean_speed);
      stream.next(m.surface_clean_area);
      stream.next(m.bottom_clean_area);
      stream.next(m.wall_clean_area);
      stream.next(m.pool_area);
      stream.next(m.pool_volume);
      stream.next(m.pool_depth);
      stream.next(m.pool_shape);
      stream.next(m.map_line_file_path);
      stream.next(m.start_turbidity);
      stream.next(m.end_turbidity);
      stream.next(m.build_map_faile_reson);
      stream.next(m.build_map_fail_count);
      stream.next(m.basket_block_time);
      stream.next(m.phy_area);
      stream.next(m.charge_position);
      stream.next(m.in_water_positon);
      stream.next(m.fall_count);
      stream.next(m.loop);
      stream.next(m.density);
      stream.next(m.in_water_signal);
      stream.next(m.in_water_level);
      stream.next(m.charge_signal);
      stream.next(m.charge_level);
      stream.next(m.mode);
      stream.next(m.clean_area);
      stream.next(m.trapped_reason);
      stream.next(m.trapped_count);
      stream.next(m.task_status);
      stream.next(m.mapped_area);
      stream.next(m.untrapped_status);
      stream.next(m.untrapped_count);
      stream.next(m.suface_border_max);
      stream.next(m.suface_border_min);
      stream.next(m.suface_border_avg);
      stream.next(m.suface_border_std);
      stream.next(m.ject_count);
      stream.next(m.suface_init_time);
      stream.next(m.bottom_avoidance_count);
      stream.next(m.miss_area);
      stream.next(m.relocation_status);
      stream.next(m.relocation_fail_reason);
      stream.next(m.bottom_border_max);
      stream.next(m.bottom_border_min);
      stream.next(m.bottom_border_avg);
      stream.next(m.bottom_border_std);
      stream.next(m.bottom_border_start_time);
      stream.next(m.bottom_border_end_time);
      stream.next(m.bottom_border_fail_time);
      stream.next(m.bottom_border_status);
      stream.next(m.bottom_init_time);
      stream.next(m.pitch);
      stream.next(m.under_view);
      stream.next(m.relocation_start_time);
      stream.next(m.relocation_end_time);
      stream.next(m.wall_avoidance_count);
      stream.next(m.wall_move);
      stream.next(m.wall_move_count);
      stream.next(m.recall_status);
      stream.next(m.compensate_reason);
      stream.next(m.compensate_retry);
      stream.next(m.compensate_status);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CleanRecord_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hj_interface::CleanRecord_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hj_interface::CleanRecord_<ContainerAllocator>& v)
  {
    s << indent << "clean_speed: ";
    Printer<float>::stream(s, indent + "  ", v.clean_speed);
    s << indent << "surface_clean_area: ";
    Printer<float>::stream(s, indent + "  ", v.surface_clean_area);
    s << indent << "bottom_clean_area: ";
    Printer<float>::stream(s, indent + "  ", v.bottom_clean_area);
    s << indent << "wall_clean_area: ";
    Printer<float>::stream(s, indent + "  ", v.wall_clean_area);
    s << indent << "pool_area: ";
    Printer<float>::stream(s, indent + "  ", v.pool_area);
    s << indent << "pool_volume: ";
    Printer<float>::stream(s, indent + "  ", v.pool_volume);
    s << indent << "pool_depth: ";
    Printer<float>::stream(s, indent + "  ", v.pool_depth);
    s << indent << "pool_shape: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pool_shape);
    s << indent << "map_line_file_path: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.map_line_file_path);
    s << indent << "start_turbidity: ";
    Printer<int32_t>::stream(s, indent + "  ", v.start_turbidity);
    s << indent << "end_turbidity: ";
    Printer<int32_t>::stream(s, indent + "  ", v.end_turbidity);
    s << indent << "build_map_faile_reson: ";
    Printer<int32_t>::stream(s, indent + "  ", v.build_map_faile_reson);
    s << indent << "build_map_fail_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.build_map_fail_count);
    s << indent << "basket_block_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.basket_block_time);
    s << indent << "phy_area: ";
    Printer<float>::stream(s, indent + "  ", v.phy_area);
    s << indent << "charge_position: ";
    Printer<int32_t>::stream(s, indent + "  ", v.charge_position);
    s << indent << "in_water_positon: ";
    Printer<int32_t>::stream(s, indent + "  ", v.in_water_positon);
    s << indent << "fall_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fall_count);
    s << indent << "loop: ";
    Printer<int32_t>::stream(s, indent + "  ", v.loop);
    s << indent << "density: ";
    Printer<int32_t>::stream(s, indent + "  ", v.density);
    s << indent << "in_water_signal: ";
    Printer<int32_t>::stream(s, indent + "  ", v.in_water_signal);
    s << indent << "in_water_level: ";
    Printer<int32_t>::stream(s, indent + "  ", v.in_water_level);
    s << indent << "charge_signal: ";
    Printer<int32_t>::stream(s, indent + "  ", v.charge_signal);
    s << indent << "charge_level: ";
    Printer<int32_t>::stream(s, indent + "  ", v.charge_level);
    s << indent << "mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.mode);
    s << indent << "clean_area: ";
    Printer<float>::stream(s, indent + "  ", v.clean_area);
    s << indent << "trapped_reason[]" << std::endl;
    for (size_t i = 0; i < v.trapped_reason.size(); ++i)
    {
      s << indent << "  trapped_reason[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.trapped_reason[i]);
    }
    s << indent << "trapped_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.trapped_count);
    s << indent << "task_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.task_status);
    s << indent << "mapped_area: ";
    Printer<float>::stream(s, indent + "  ", v.mapped_area);
    s << indent << "untrapped_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.untrapped_status);
    s << indent << "untrapped_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.untrapped_count);
    s << indent << "suface_border_max: ";
    Printer<float>::stream(s, indent + "  ", v.suface_border_max);
    s << indent << "suface_border_min: ";
    Printer<float>::stream(s, indent + "  ", v.suface_border_min);
    s << indent << "suface_border_avg: ";
    Printer<float>::stream(s, indent + "  ", v.suface_border_avg);
    s << indent << "suface_border_std: ";
    Printer<float>::stream(s, indent + "  ", v.suface_border_std);
    s << indent << "ject_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ject_count);
    s << indent << "suface_init_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.suface_init_time);
    s << indent << "bottom_avoidance_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bottom_avoidance_count);
    s << indent << "miss_area: ";
    Printer<float>::stream(s, indent + "  ", v.miss_area);
    s << indent << "relocation_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.relocation_status);
    s << indent << "relocation_fail_reason: ";
    Printer<int32_t>::stream(s, indent + "  ", v.relocation_fail_reason);
    s << indent << "bottom_border_max: ";
    Printer<float>::stream(s, indent + "  ", v.bottom_border_max);
    s << indent << "bottom_border_min: ";
    Printer<float>::stream(s, indent + "  ", v.bottom_border_min);
    s << indent << "bottom_border_avg: ";
    Printer<float>::stream(s, indent + "  ", v.bottom_border_avg);
    s << indent << "bottom_border_std: ";
    Printer<float>::stream(s, indent + "  ", v.bottom_border_std);
    s << indent << "bottom_border_start_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bottom_border_start_time);
    s << indent << "bottom_border_end_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bottom_border_end_time);
    s << indent << "bottom_border_fail_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bottom_border_fail_time);
    s << indent << "bottom_border_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bottom_border_status);
    s << indent << "bottom_init_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bottom_init_time);
    s << indent << "pitch[]" << std::endl;
    for (size_t i = 0; i < v.pitch.size(); ++i)
    {
      s << indent << "  pitch[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pitch[i]);
    }
    s << indent << "under_view: ";
    Printer<int32_t>::stream(s, indent + "  ", v.under_view);
    s << indent << "relocation_start_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.relocation_start_time);
    s << indent << "relocation_end_time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.relocation_end_time);
    s << indent << "wall_avoidance_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.wall_avoidance_count);
    s << indent << "wall_move[]" << std::endl;
    for (size_t i = 0; i < v.wall_move.size(); ++i)
    {
      s << indent << "  wall_move[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.wall_move[i]);
    }
    s << indent << "wall_move_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.wall_move_count);
    s << indent << "recall_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.recall_status);
    s << indent << "compensate_reason: ";
    Printer<int32_t>::stream(s, indent + "  ", v.compensate_reason);
    s << indent << "compensate_retry: ";
    Printer<int32_t>::stream(s, indent + "  ", v.compensate_retry);
    s << indent << "compensate_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.compensate_status);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HJ_INTERFACE_MESSAGE_CLEANRECORD_H
